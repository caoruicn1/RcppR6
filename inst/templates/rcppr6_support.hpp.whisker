// Generated by rcppr6 ({{{rcppr6.version}}}): do not edit by hand -*-c++-*-
#ifndef _{{{package.NAME}}}_RCPPR6_SUPPORT_HPP_
#define _{{{package.NAME}}}_RCPPR6_SUPPORT_HPP_

// These functions are all used in rcppr6_post.hpp, and require Rcpp
// to be loaded.
//
// It's possible that this will move into the rcppr6_post.hpp file
// itself at some point.
#include <Rcpp.h>

namespace {{{package.name}}} {
namespace rcppr6 {

// Not quite traits, but should be close enough.  This is non-API!
namespace traits {
template <typename T>
std::string class_name() {
  Rcpp::stop("Unknown class");
  return ""; // never get here.
}
template <typename T>
std::string package_name() {
  Rcpp::stop("Unknown class");
  return ""; // never get here.
}

template <typename T>
std::string class_name(const T&) {
  return class_name<T>();
}
template <typename T>
std::string package_name(const T&) {
  return package_name<T>();
}
}

// Get the top level class attribute from an object.  Returns the
// empty string if it's not there, or if it's the zero length
// character vector.  Could be modified to return the i'th class
// element easily enough, but at that point we might as well return
// the whole bloody thing.  This might get replaced with "inherits" at
// some point, where we loop over the class vector.
inline std::string get_class(Rcpp::RObject x) {
  if (x.hasAttribute("class")) {
    Rcpp::CharacterVector cx(x.attr("class"));
    if (cx.size() > 0) {
      return Rcpp::as<std::string>(cx[0]); // Always the first element.
    } else {
      return "";
    }
  } else {
    return "";
  }
}

template <typename T>
void check_ptr_valid(Rcpp::XPtr<T> p) {
  T* test = p;
  if (test == NULL) {
    Rcpp::stop("Pointer is NULL");
  }
}

// This is absolutely basic, and does not do much more than XPtr.
// Differences are:
//   - pointer validity checking when an externalptr is recieved.
//   - knows what "type" of pointer it contains and checks this when
//     recieved
//   - can generate a special R6 object on return
//
// Possible improvements:
//   - the appropriate generator should really be a static member of
//     the class, which we generate only when it's not been
//     initialised yet.  That will save a few calls, but will take
//     care through a load/unload cycle.
//   - first-class access to *general* R6 classes would be preferable
//     to the dodgy 'find' call.
template <typename T>
class RcppR6 {
public:
  RcppR6(SEXP x) : ptr(ptr_from_R6(x)) {}
  RcppR6(const T& x) : ptr(new T(x), true) {}
  T& operator*() const {
    return *ptr;
  }
  inline operator T*(){ return (T*)(ptr); }
  T* operator->() const {
    return &(*ptr);
  }
  Rcpp::XPtr<T> ptr;
  // Convert from an R6 object from R:
  static Rcpp::XPtr<T> ptr_from_R6(Rcpp::RObject x) {
    const std::string classname = traits::class_name<T>();
    if (get_class(x) == classname) {
      Rcpp::Environment xe = Rcpp::as<Rcpp::Environment>(x);
      // TODO: Will go all the way up to global environment!
      Rcpp::XPtr<T> ptr = Rcpp::as<Rcpp::XPtr<T> >(xe.find("ptr"));
      check_ptr_valid<T>(ptr);
      return ptr;
    } else {
      Rcpp::stop("Expected an object of type R6 / " + classname);
      return Rcpp::as<Rcpp::XPtr<T> >(x); // Won't get here
    }
  }
  SEXP to_R6() const {
    const std::string classname(traits::class_name<T>());
    const std::string packagename(traits::package_name<T>());
    Rcpp::Environment base("package:base");
    Rcpp::Function getNamespace = base["getNamespace"];
    Rcpp::Environment pkg = getNamespace(packagename);
    // TODO: should Generator also be environment?
    // TODO: need to deal with failure here (i.e. R_NilValue)
    Rcpp::List Generator = pkg["{{{rcppr6.r6_generator_prefix}}}" + classname];
    Rcpp::Function Generator_new = Generator["new"];
    return Generator_new(ptr);
  }
};

}
}

#endif
